import Pyro4
import os
import warnings
from datetime import datetime
import struct
import numpy as np
import socket

from pynq.mmio import MMIO
from pynq.ps import CPU_ARCH_IS_SUPPORTED, CPU_ARCH, ZYNQ_ARCH, ZU_ARCH
from pynq.ps import Clocks

from .constants import PL_SERVER_FILE
from .constants import PYNQ_PATH
from .constants import BS_BOOT, TCL_BOOT, HWH_BOOT
from .parse_tcl import TCL
from .parse_hwh import HWH


class _NullParser:
    def __init__(self):
        self.ip_dict = {}
        self.gpio_dict = {}
        self.interrupt_controllers = {}
        self.interrupt_pins = {}
        self.hierarchy_dict = {}

class _BitstreamDownloader:
    """This class instantiates a PL bitstream using FPGA manager to download

    Note
    ----
    This class inherits from the _BitstreamMeta class

    """
    BS_FPGA_MAN = "/sys/class/fpga_manager/fpga0/firmware"
    BS_FPGA_MAN_FLAGS = "/sys/class/fpga_manager/fpga0/flags"

    def __init__(self, bitfile_name):
        self.bitfile_name = bitfile_name
    
    def download(self):
        """The method to download the bitstream onto PL.

        Note
        ----
        The class variables held by the singleton PL will also be updated.

        Returns
        -------
        None

        """
        if not os.path.exists(self.BS_FPGA_MAN):
            raise RuntimeError("Could not find programmable device")

        bin_file = os.path.basename(self.bitfile_name).replace('.bit', '.bin')
        self.bin_path = '/lib/firmware/' + bin_file
        self.convert_bit_to_bin()
        with open(self.BS_FPGA_MAN_FLAGS, "w") as fd:
            # The 20 flag tells the driver that we are passing in an old-style
            # raw binary bitstream so we don't need to add the new-style header
            # to the bin file
            fd.write('20')
        with open(self.BS_FPGA_MAN, 'w') as fd:
            fd.write(bin_file)

    def convert_bit_to_bin(self):
        """The method to convert a .bit file to .bin file.

        A .bit file is generated by Vivado, but .bin files are needed
        by the Zynq Ultrascale FPGA manager driver. Users must specify
        the absolute path to the source .bit file, and the destination
        .bin file and have read/write access to both paths. 

        Note
        ----
        Imlemented based on: https://blog.aeste.my/?p=2892

        Returns
        -------
        None

        """
        bit_data = self.parse_bit_header()
        bit_buffer = np.frombuffer(bit_data['data'], dtype=np.int32, offset=0)
        bin_buffer = bit_buffer.byteswap()
        bin_buffer.tofile(self.bin_path, "")

    def parse_bit_header(self):
        """The method to parse the header of a bitstream.

        The returned dictionary has the following keys:
        "design": str, the Vivado project name that generated the bitstream;
        "version": str, the Vivado tool version that generated the bitstream;
        "part": str, the Xilinx part name that the bitstream targets;
        "date": str, the date the bitstream was compiled on;
        "time": str, the time the bitstream finished compilation;
        "length": int, total length of the bitstream (in bytes);
        "data": binary, binary data in .bit file format

        Returns
        -------
        Dict
            A dictionary containing the header information.

        Note
        ----
        Implemented based on: https://blog.aeste.my/?p=2892

        """
        with open(self.bitfile_name, 'rb') as bitf:
            finished = False
            offset = 0
            contents = bitf.read()
            bit_dict = {}

            # Strip the (2+n)-byte first field (2-bit length, n-bit data)
            length = struct.unpack('>h', contents[offset:offset + 2])[0]
            offset += 2 + length

            # Strip a two-byte unknown field (usually 1)
            offset += 2

            # Strip the remaining headers. 0x65 signals the bit data field
            while not finished:
                desc = contents[offset]
                offset += 1

                if desc != 0x65:
                    length = struct.unpack('>h',
                                           contents[offset:offset + 2])[0]
                    offset += 2
                    fmt = ">{}s".format(length)
                    data = struct.unpack(fmt,
                                         contents[offset:offset + length])[0]
                    data = data.decode('ascii')[:-1]
                    offset += length

                if desc == 0x61:
                    s = data.split(";")
                    bit_dict['design'] = s[0]
                    bit_dict['version'] = s[2]
                elif desc == 0x62:
                    bit_dict['part'] = data
                elif desc == 0x63:
                    bit_dict['date'] = data
                elif desc == 0x64:
                    bit_dict['time'] = data
                elif desc == 0x65:
                    finished = True
                    length = struct.unpack('>i',
                                           contents[offset:offset + 4])[0]
                    offset += 4
                    # Expected length values can be verified in the chip TRM
                    bit_dict['length'] = str(length)
                    if length + offset != len(contents):
                        raise RuntimeError("Invalid length found")
                    bit_dict['data'] = contents[offset:offset + length]
                else:
                    raise RuntimeError("Unknown field: {}".format(hex(desc)))
            return bit_dict


def _check_file(filename, filetype):
    if not os.path.exists(filename):
        raise RuntimeError(
                "Could not open {} file {}".format(filetype, filename))
    if os.stat(filename).st_uid != 0:
        raise RuntimeError(
                ("{} not owned by root - non-root users may only download " +
                "overlays fully owned by root").format(filename))


@Pyro4.expose
@Pyro4.behavior(instance_mode="single")
class PLServer:
    """This is the Pyro-based server for controlling the programmable
    logic

    This is not a class for users. Hence there is no attribute or method
    exposed to users.

    Note
    ----
    If this metaclass is parsed on an unsupported architecture it will issue
    a warning and leave class variables undefined

    """
    _bitfile_name = BS_BOOT
    _timestamp = ""

    if CPU_ARCH_IS_SUPPORTED:
        if os.path.exists(HWH_BOOT):
            parser = HWH(HWH_BOOT)
            _ip_dict = parser.ip_dict
            _gpio_dict = parser.gpio_dict
            _interrupt_controllers = parser.interrupt_controllers
            _interrupt_pins = parser.interrupt_pins
            _hierarchy_dict = parser.hierarchy_dict
        elif os.path.exists(TCL_BOOT):
            parser = TCL(TCL_BOOT)
            _ip_dict = parser.ip_dict
            _gpio_dict = parser.gpio_dict
            _interrupt_controllers = parser.interrupt_controllers
            _interrupt_pins = parser.interrupt_pins
            _hierarchy_dict = parser.hierarchy_dict
        else:
            _ip_dict = {}
            _gpio_dict = {}
            _interrupt_controllers = {}
            _interrupt_pins = {}
            _hierarchy_dict = {}
        _status = 1
        _server = None
        _host = None
        _remote = None
    else:
            _ip_dict = {}
            _gpio_dict = {}
            _interrupt_controllers = {}
            _interrupt_pins = {}
            _hierarchy_dict = {}

    @property
    def bitfile_name(self):
        """The getter for the attribute `bitfile_name`.

        Returns
        -------
        str
            The absolute path of the bitstream currently on PL.

        """
        return self._bitfile_name

    @property
    def timestamp(self):
        """The getter for the attribute `timestamp`.

        Returns
        -------
        str
            Bitstream download timestamp.

        """
        return self._timestamp

    @property
    def ip_dict(self):
        """The getter for the attribute `ip_dict`.

        Returns
        -------
        dict
            The dictionary storing addressable IP instances; can be empty.

        """
        return self._ip_dict

    @property
    def gpio_dict(self):
        """The getter for the attribute `gpio_dict`.

        Returns
        -------
        dict
            The dictionary storing the PS GPIO pins.

        """
        return self._gpio_dict

    @property
    def interrupt_controllers(self):
        """The getter for the attribute `interrupt_controllers`.

        Returns
        -------
        dict
            The dictionary storing interrupt controller information.

        """
        return self._interrupt_controllers

    @property
    def interrupt_pins(self):
        """The getter for the attribute `interrupt_pins`.

        Returns
        -------
        dict
            The dictionary storing the interrupt endpoint information.

        """
        return self._interrupt_pins

    @property
    def hierarchy_dict(self):
        """The getter for the attribute `hierarchy_dict`

        Returns
        -------
        dict
            The dictionary containing the hierarchies in the design

        """
        return self._hierarchy_dict

    def load_ip_data(self, ip_name, data, zero=False):
        """This method writes data to the addressable IP.

        Note
        ----
        The data is assumed to be in binary format (.bin). The data
        name will be stored as a state information in the IP dictionary.

        Parameters
        ----------
        ip_name : str
            The name of the addressable IP.
        data : str
            The absolute path of the data to be loaded.
        zero : bool
            Zero out the address of the IP not covered by data

        Returns
        -------
        None

        """
        with open(data, 'rb') as bin_file:
            size = os.fstat(bin_file.fileno()).st_size
            target_size = cls._ip_dict[ip_name]['addr_range']
            if size > target_size:
                raise RuntimeError("Binary file too big for IP")
            mmio = MMIO(cls._ip_dict[ip_name]['phys_addr'], target_size)
            buf = bin_file.read(size)
            mmio.write(0, buf)
            if zero and size < target_size:
                mmio.write(size, b'\x00' * (target_size - size))

        cls._ip_dict[ip_name]['state'] = data

    def download(self, bitfile_name, tcl_file=None, hwh_file=None):
        sock = Pyro4.current_context.client.sock
        pid, uid, gid = struct.unpack(
                "3i", sock.getsockopt(socket.SOL_SOCKET, socket.SO_PEERCRED, 12))

        # Perform security check - either the user must be root or all files must be
        # owned by root
        if uid != 0:
            _check_file(bitfile_name, "bitstream")
            if tcl_file is not None:
                _check_file(tcl_file, "TCL file")
            if hwh_file is not None:
                _check_file(hwh_file, "HWH file")

        if hwh_file is not None:
            parser = HWH(hwh_file)
        elif tcl_file is not None:
            parser = TCL(tcl_file)
        else:
            parser = _NullParser()

        downloader = _BitstreamDownloader(bitfile_name)
        downloader.download()

        self._bitfile_name = bitfile_name
        t = datetime.now()
        self._timestamp = "{}/{}/{} {}:{}:{} +{}".format(
                t.year, t.month, t.day,
                t.hour, t.minute, t.second, t.microsecond)

        self._ip_dict = parser.ip_dict
        self._gpio_dict = parser.gpio_dict
        self._interrupt_controllers = parser.interrupt_controllers
        self._interrupt_pins = parser.interrupt_pins
        self._hierarchy_dict = parser.hierarchy_dict
        self._clock_dict = parser.clock_dict

        for i in self._clock_dict:
            enable = self._clock_dict[i]['enable']
            div0 = self._clock_dict[i]['divisor0']
            div1 = self._clock_dict[i]['divisor1']
            if enable:
                Clocks.set_pl_clk(i, div0, div1)
            else:
                Clocks.set_pl_clk(i)

        return self._timestamp

def _stop_server():
    """Entry point for the stop_pl_server.py script

    This function will attempt to stop the PL server in
    a controlled manner. It should not be called by user code

    """
    pass


def _start_server():
    """Entry point for the start_pl_server.py script

    Starts the PL server using the default server file.  Should
    not be called by user code - use PL.setup() instead to
    customise the server.

    """
    if os.path.exists(PL_SERVER_FILE):
        os.remove(PL_SERVER_FILE)
    daemon = Pyro4.Daemon(unixsocket=PL_SERVER_FILE)
    uri = daemon.register(PLServer, "pl.server")
    os.chmod(PL_SERVER_FILE, 0o666)
    print("Server started")
    daemon.requestLoop()

